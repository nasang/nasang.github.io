<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="SsJLQVCu35H-wMDMbIHpAv2Y65KagLlcfArj6qaf0CY"> <meta name="msvalidate.01" content="1E11C54B5E73180465BA7047C6DD4D83"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Notes of A Tour of C++ | Na Sang </title> <meta name="author" content="Na Sang"> <meta name="description" content=""> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?b8ef20a79f5306f65378fcc706e98671" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%98%80%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nasang.github.io/blog/book/2025/A-Tour-of-C++-Notes/"> <link rel="stylesheet" href="https://unpkg.com/@coreui/icons/css/brand.min.css"> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Na</span> Sang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Notes of A Tour of C++</h1> <p class="post-meta"> Created in May 03, 2025   ·   33 min read </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/c"> <i class="fa-solid fa-hashtag fa-sm"></i> C++</a>   <a href="/blog/tag/language"> <i class="fa-solid fa-hashtag fa-sm"></i> language</a>   ·   <a href="/blog/category/book"> <i class="fa-solid fa-tag fa-sm"></i> book</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Disclaimer: This note is based on <a href="https://www.stroustrup.com/tour3.html" rel="external nofollow noopener" target="_blank"><em>A Tour of C++ (Third Edition)</em></a> by <a href="https://www.stroustrup.com/index.html" rel="external nofollow noopener" target="_blank">Bjarne Stroustrup</a> and is intended for learning purposes only. All rights to the original work belong to the author and publisher.</p> <h2 id="1-the-basics">1 The Basics</h2> <p>An overview of C++ syntax, memory model, and basic mechanisms for organizing code.</p> <h3 id="programs">Programs</h3> <p>C++ is a <strong>compiled language</strong>: a program’s <code class="language-plaintext highlighter-rouge">source (code) files</code> are compiled into <code class="language-plaintext highlighter-rouge">object files</code>, which are then linked to produce an <code class="language-plaintext highlighter-rouge">executable program</code>. Executables are not portable, as they are built for a specific hardware/system combination.</p> <p>C++ is a <strong>statically typed</strong> language: the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at the point of use. The <code class="language-plaintext highlighter-rouge">type</code> of an object determines the set of applicable <code class="language-plaintext highlighter-rouge">operations</code> and its <code class="language-plaintext highlighter-rouge">layout in memory</code>.</p> <h4 id="hello-world">Hello, World!</h4> <p>Every C++ program must have exatly one global function named <code class="language-plaintext highlighter-rouge">main()</code>, which is the program’s entry point.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">import std;</code> makes the declarations from the standard library available. <ul> <li>This <code class="language-plaintext highlighter-rouge">import</code> directive is new in C++20. Presenting the entire standard library as a module named <code class="language-plaintext highlighter-rouge">std</code> is not yet fully standardardized.</li> </ul> </li> <li>The operator <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> (“put to”) writes its second argument onto its first. <ul> <li>In this case, the <em>string literal</em> <code class="language-plaintext highlighter-rouge">"Hello, World!\n"</code> is written to the <em>standard output stream</em> <code class="language-plaintext highlighter-rouge">std::cout</code>.</li> </ul> </li> </ul> <p>Note: Normally, non-void functions must explicitly return a value, but <code class="language-plaintext highlighter-rouge">main()</code> is an exception as specified by the standard. (<a href="https://stackoverflow.com/questions/19293642/why-does-the-main-function-work-with-no-return-value" rel="external nofollow noopener" target="_blank">Reference</a>)</p> <h3 id="functions">Functions</h3> <p>In C++, functions specify how operations are performed and are the primary means of executing code. A function must be declared before it can be called.</p> <p><strong>Declaration of a function</strong>: <code class="language-plaintext highlighter-rouge">&lt;return_type&gt; &lt;function_name&gt;(&lt;argument_type_0&gt;, &lt;argument_type_1&gt;, ...);</code>. Argument names are optional in declarations (but helpful to readers); they are ignored by the compiler unless the declaration is also a definition.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">square</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
</code></pre></div></div> <p><strong>Type of a function</strong>: <code class="language-plaintext highlighter-rouge">&lt;return_type&gt;(&lt;argument_type_0&gt;, &lt;argument_type_1&gt;, ...)</code>. For a class’s member function, the class name is also part of the type: <code class="language-plaintext highlighter-rouge">&lt;return_type&gt; &lt;class_name&gt;::(&lt;argument_type_0&gt;, &lt;argument_type_1&gt;, ...)</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span> 
<span class="c1">// type: double(const vector&lt;double&gt;&amp;, int)</span>

<span class="kt">char</span><span class="o">&amp;</span> <span class="n">String</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span> 
<span class="c1">// type: char&amp; String::(int)</span>
</code></pre></div></div> <p><strong>Argument passing</strong>: Follows the semantics of initialization. Argument types are <code class="language-plaintext highlighter-rouge">checked</code>, and <code class="language-plaintext highlighter-rouge">implicit type conversions</code> may occur.</p> <p><strong>Function overloading</strong>: Multiple functions can share the <code class="language-plaintext highlighter-rouge">same name</code> if they differ in <code class="language-plaintext highlighter-rouge">argument types</code>. Each function should implement the same semantics. The compiler will choose the <code class="language-plaintext highlighter-rouge">most appropriate</code> function to invoke for each call:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">user</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// call print(int)</span>
  <span class="n">print</span><span class="p">(</span><span class="mf">9.65</span><span class="p">);</span> <span class="c1">// call print(double)</span>
<span class="p">}</span>
</code></pre></div></div> <p>If two matches are equally good, the call is <code class="language-plaintext highlighter-rouge">ambiguous</code>, and the compiler emits an error:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">user2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// error: ambiguous</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="types-variables-and-arithmetic">Types, Variables, and Arithmetic</h3> <p>A <strong>declaration</strong> is a statement that introduces an entity into the program and specifies its type:</p> <ul> <li>A <code class="language-plaintext highlighter-rouge">type</code> defines a set of possible values and a set of operations (for an object).</li> <li>An <code class="language-plaintext highlighter-rouge">object</code> is some memory that holds a value of some type.</li> <li>A <code class="language-plaintext highlighter-rouge">value</code> is a set of bits interpreted according to to a type.</li> <li>A <code class="language-plaintext highlighter-rouge">variable</code> is a named object.</li> </ul> <p>Type sizes are implementation-defined (i.e., can vary among different machines). Use <code class="language-plaintext highlighter-rouge">sizeof(type)</code> to get the size in bytes. For example, <code class="language-plaintext highlighter-rouge">sizeof(char)</code> equals <code class="language-plaintext highlighter-rouge">1</code>, and <code class="language-plaintext highlighter-rouge">sizeof(int)</code> is often <code class="language-plaintext highlighter-rouge">4</code>. When we want a type of a specific size, we use a standard-library type alias, such as <code class="language-plaintext highlighter-rouge">int32_t</code>.</p> <p>Numbers can be floating-point or integers.</p> <ul> <li>Floating-point: <code class="language-plaintext highlighter-rouge">3.14</code>, <code class="language-plaintext highlighter-rouge">314e-2</code> </li> <li>Integer literals are by default decimal. <ul> <li> <code class="language-plaintext highlighter-rouge">0b</code> prefix: binary, e.g., <code class="language-plaintext highlighter-rouge">0b10101010</code> </li> <li> <code class="language-plaintext highlighter-rouge">0x</code> prefix: hexadecimal, e.g., <code class="language-plaintext highlighter-rouge">0xBAD12CE3</code> </li> <li> <code class="language-plaintext highlighter-rouge">0</code> prefix: octal (base 8), e.g., <code class="language-plaintext highlighter-rouge">0334</code> </li> </ul> </li> </ul> <p>We can use a signal quote <code class="language-plaintext highlighter-rouge">'</code> as a digit separator for readability, e.g., <code class="language-plaintext highlighter-rouge">3.14159'26525'89793</code>.</p> <h4 id="arithmetic">Arithmetic</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="o">^</span><span class="n">y</span><span class="p">;</span> <span class="c1">// bitwise exclusive OR</span>
<span class="o">~</span><span class="n">x</span><span class="p">;</span> <span class="c1">// bitwise complement</span>
</code></pre></div></div> <h4 id="initialization">Initialization</h4> <p>An object must be initialized before it can be used. C++ offers several syntaxes for initialization, such <code class="language-plaintext highlighter-rouge">=</code>, and a universal form based on <code class="language-plaintext highlighter-rouge">{}</code> initializer lists.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">d1</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">d2</span> <span class="p">{</span><span class="mf">2.3</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">d3</span> <span class="o">=</span> <span class="p">{</span><span class="mf">2.3</span><span class="p">};</span> <span class="c1">// the = is optional with {...}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</code></pre></div></div> <p><strong>Narrowing converions</strong>, such as <code class="language-plaintext highlighter-rouge">double</code> to <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">int</code> to <code class="language-plaintext highlighter-rouge">char</code> are allowed and implicitly applied with <code class="language-plaintext highlighter-rouge">=</code>, but not allowed with <code class="language-plaintext highlighter-rouge">{}</code> to prevent information loss.</p> <p>When the type can be deduced from the initializer, you can omit it using <code class="language-plaintext highlighter-rouge">auto</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// bool</span>
<span class="k">auto</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'x'</span><span class="p">;</span> <span class="c1">// char</span>
<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span> <span class="c1">// int</span>
</code></pre></div></div> <p>With <code class="language-plaintext highlighter-rouge">auto</code>, we tend to use the <code class="language-plaintext highlighter-rouge">=</code> because there is no potentially troublesome type conversion involved.</p> <h3 id="scope-and-lifetime">Scope and Lifetime</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span> <span class="c1">// global</span>

<span class="kt">void</span> <span class="nf">fct</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="c1">// fct is global</span>
                  <span class="c1">// arg is local</span>
<span class="p">{</span>
  <span class="n">string</span> <span class="n">motto</span> <span class="p">{</span><span class="s">"Who dares wins"</span><span class="p">};</span> <span class="c1">// motto is local</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Record</span><span class="p">{</span><span class="s">"Hume"</span><span class="p">};</span> <span class="c1">// p points to an unnamed Record (created by new)</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Record</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// name is a member of Record</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="constants">Constants</h3> <h3 id="pointers-arrays-and-references">Pointers, Arrays, and References</h3> <p>An <strong>array</strong> is a contiguous block of memory containing elements of the same type. It is the most primitive form of data collection and closely reflects what the hardware provides.</p> <p>In a <em>declaration</em>:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">[]</code> means <code class="language-plaintext highlighter-rouge">"array of"</code> </li> <li> <code class="language-plaintext highlighter-rouge">*</code> means <code class="language-plaintext highlighter-rouge">"pointer to"</code> </li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="c1">// array of 6 characters</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// pointer to character</span>
</code></pre></div></div> <p>In an <em>expression</em>:</p> <ul> <li>Unary prefix <code class="language-plaintext highlighter-rouge">&amp;</code> means <code class="language-plaintext highlighter-rouge">"address of"</code> </li> <li>Unary prefix <code class="language-plaintext highlighter-rouge">*</code> means <code class="language-plaintext highlighter-rouge">"content of"</code>:</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// p points to v's fourth element</span>
<span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// *p is the content that p points to</span>
</code></pre></div></div> <p>C++ supports a <strong>range-for-statement</strong>, for iterating over sequences:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> 
  <span class="c1">// we don't have to speficy an array bound when we initialize it with a list</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span>  <span class="c1">// copies each element into x</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">})</span> <span class="c1">// iterates over an initializer list</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="c1">// ... </span>
<span class="p">}</span>
</code></pre></div></div> <p>To <strong>avoid copying</strong> and instead work with each element directly, use a reference:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> 

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// x refers to each element</span>
    <span class="o">++</span><span class="n">x</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>A <strong>reference</strong> behaves like a pointer except that:</p> <ul> <li>No need to access the value with <code class="language-plaintext highlighter-rouge">*</code> </li> <li>Cannot be reseated to refer to another object once initialized</li> </ul> <p>Reference are particualarly useful for specifying function arguments. This avoids copying the entire object and allows in-place modification.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div> <p>To allow <strong>read-only access without copying</strong>, use a <code class="language-plaintext highlighter-rouge">const reference</code> (i.e., a reference to a <code class="language-plaintext highlighter-rouge">const</code>):</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div> <p>In declarations, operators like <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">*</code>, and <code class="language-plaintext highlighter-rouge">&amp;</code> are called <strong>declarator operators</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="c1">// T[n]: a is an array of n elements of type T</span>
<span class="n">T</span><span class="o">*</span> <span class="n">p</span>    <span class="c1">// T*: p is a pointer to T</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">r</span>    <span class="c1">// T&amp;: r is a reference to T</span>
<span class="n">T</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1">// T(A): f is a function taking an argument of type A and returning a result of type T</span>
</code></pre></div></div> <h4 id="the-null-pointer">The Null Pointer</h4> <p><code class="language-plaintext highlighter-rouge">nullptr</code> represents a null pointer—used when no valid object is available to point to. It replaces the older conventions <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">NULL</code>, which could be confusing because they are also valid integer values.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">count_x</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// equivalent to while(*p != 0)</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> 
      <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="o">++</span><span class="n">p</span><span class="p">;</span> <span class="c1">// advance the pointer to the next element</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">char*</code> denotes a C-style string. Since characters in a string literal are immutable, so the function parameter is declared as <code class="language-plaintext highlighter-rouge">const char*</code>.</p> <p>Thre is no null referece. A reference must refer to a valid object.</p> <h3 id="tests">Tests</h3> <p>C++ provides a set of statements for expressing selection and looping, such as <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">switch</code>, <code class="language-plaintext highlighter-rouge">while</code>, and <code class="language-plaintext highlighter-rouge">for</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">accept</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Do you want to proceed (y or n)?</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">answer</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">anser</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> operator (<code class="language-plaintext highlighter-rouge">"get from"</code>) is used for input; <code class="language-plaintext highlighter-rouge">cin</code> is the standard input stream.</p> <p>An <code class="language-plaintext highlighter-rouge">if</code>-statement can introduce a variable and test it.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>A name declared in a condition is in scope on both braches of the <code class="language-plaintext highlighter-rouge">if</code>-statement. This helps keep the scope of the variable limited, improving redeability and reducing errors.</p> <p>Prefer omitting explicit mention of the condition, when testing a variable against <code class="language-plaintext highlighter-rouge">0</code> or the <code class="language-plaintext highlighter-rouge">nullptr</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">vetor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="mapping-to-hardware">Mapping to Hardware</h3> <p>C++ offers a direct mapping to hardware. A fundamental operation is typically implemented with a single <code class="language-plaintext highlighter-rouge">machine operation</code>. For example, adding two <code class="language-plaintext highlighter-rouge">int</code>s, executes an integer add machine instruction.</p> <p>C++ views a machine’s memory as a sequence of memory locations where it can store <em>typed</em> objects and address them using <code class="language-plaintext highlighter-rouge">pointer</code>s. The numeric value of a pointer corresponds to a machine address.</p> <p>The basic machine model of C and C++ is based on <code class="language-plaintext highlighter-rouge">computer hardware</code>. The simple mapping of fundamental language constructs to hardware is curcial for the <code class="language-plaintext highlighter-rouge">raw low-level performance</code> for which C and C++ have been famous for decades.</p> <h4 id="assignment">Assignment</h4> <p>An <code class="language-plaintext highlighter-rouge">assignment</code> of a built-in type is a simple machine <code class="language-plaintext highlighter-rouge">copy</code> operation. The assigned-to object gets the value from the assigned object, yielding two <strong>independent</strong> objects with the same value.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// y's value is copied to x</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// q's value is copied to p; so p == q, and *p == *q</span>
</code></pre></div></div> <p>A reference and a pointer both refer/point to an object and both are represented in memory as a machine address. However, <strong>assignment to a reference does not change what the reference refers to but assigns to the referenced object</strong>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// r refers to x </span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// r2 refers to y</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r2</span><span class="p">;</span> <span class="c1">// read through r2, write through r: x becomes 3</span>
</code></pre></div></div> <h3 id="initialization-1">Initialization</h3> <p>The assigned-to object must have a value, for an assignment to work correctly. On the other hand, initialization is to make an uninitialized piece of memory into a valid object.</p> <p>We cannot have an unintialized reference.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">&amp;</span> <span class="n">r2</span><span class="p">;</span> <span class="c1">// error: uninitialized reference</span>
<span class="n">r2</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</code></pre></div></div> <p>If we could, <code class="language-plaintext highlighter-rouge">r2=99</code> would assign <code class="language-plaintext highlighter-rouge">99</code> to some unspeficied memory location, eventually leading to bad results or a crash.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span> <span class="c1">// bind r to x (r refers to x)</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// bind r to x (r refers to x); not any form of value copy</span>
</code></pre></div></div> <p>The basic semantices of <code class="language-plaintext highlighter-rouge">argument passing</code> and <code class="language-plaintext highlighter-rouge">function value return</code> are that of initialization.</p> <h2 id="2-user-defined-types">2 User-Defined Types</h2> <ul> <li> <strong>Built-in types</strong> are built from <em>fundamental types</em>, <code class="language-plaintext highlighter-rouge">const</code> modifier, and <em>declarator operators</em>.</li> <li> <strong>User-defined types</strong> are built out of other types using C++’s abstraction mechanisims, referred to as <em>classes</em> and <em>enumerations</em>.</li> </ul> <h3 id="structures">Structures</h3> <p>The first step in creating a new type is often to group related elements into a <code class="language-plaintext highlighter-rouge">struct</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>To use it:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vector_init</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v</span><span class="p">.</span><span class="n">elem</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
  <span class="n">v</span><span class="p">.</span><span class="n">sz</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">new</code> allocates memory on the <em>free store</em> (a.k.a <em>dynamic memory</em>, or <em>heap</em>), which must be explicitly deallocated with <code class="language-plaintext highlighter-rouge">delete</code>.</p> <p>Use <code class="language-plaintext highlighter-rouge">.</code> to access <code class="language-plaintext highlighter-rouge">struct</code> members through a name, or a reference and <code class="language-plaintext highlighter-rouge">-&gt;</code> through a pointer.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Vector</span> <span class="n">v</span><span class="p">,</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">rv</span><span class="p">,</span> <span class="n">Vector</span><span class="o">*</span> <span class="n">pv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">sz</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">rv</span><span class="p">.</span><span class="n">sz</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="n">pv</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="classes">Classes</h3> <p>While a <code class="language-plaintext highlighter-rouge">struct</code> expose all members by default, a <code class="language-plaintext highlighter-rouge">class</code> allows encapsulation: separating interface (<code class="language-plaintext highlighter-rouge">public</code> members) from implementation (<code class="language-plaintext highlighter-rouge">private</code> members).</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">]},</span> <span class="n">sz</span><span class="p">{</span><span class="n">s</span><span class="p">}</span> <span class="p">{}</span>
  <span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">];}</span>
  <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">sz</span><span class="p">;}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The number of elements in a <code class="language-plaintext highlighter-rouge">Vector</code> can vary across objects and even over the lifetime of a single object. However, the <code class="language-plaintext highlighter-rouge">Vector</code> instance itself always has a fixed size. This illustrates a common C++ technique: using a fixed-size object as a <em>handle</em> to manage a variable-size block of data allocated elsewhere.</p> <p>A <strong>constructor</strong> (a member function with the same name as its class) initializes members using a <em>member initializer list</em>: <code class="language-plaintext highlighter-rouge">elem{new double[s]}, sz{s}</code>.</p> <p>We can define constructors and other member functions for a <code class="language-plaintext highlighter-rouge">sturct</code> as well. There is no fundamental difference between a <code class="language-plaintext highlighter-rouge">struct</code> and a <code class="language-plaintext highlighter-rouge">class</code>; a <code class="language-plaintext highlighter-rouge">struct</code> is simply a <code class="language-plaintext highlighter-rouge">class</code> with members <code class="language-plaintext highlighter-rouge">public</code> by default.</p> <h3 id="enumerations">Enumerations</h3> <p>Enumerations are used to represent small sets of named constants (integer values), improving code readability and safety.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">green</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Traffic_light</span> <span class="p">{</span> <span class="n">green</span><span class="p">,</span> <span class="n">yellow</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">enum class</code> introduces <strong>strongly typed</strong> and <strong>scoped</strong> enums.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Color</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>                <span class="c1">// error: which red?</span>
<span class="n">Color</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">Traffic_light</span><span class="o">::</span><span class="n">red</span><span class="p">;</span> <span class="c1">// error: not a Color</span>
<span class="n">Color</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>         <span class="c1">// OK</span>
<span class="k">auto</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>          <span class="c1">// OK</span>
</code></pre></div></div> <p>Implicit conversion to/from integers is not allowed:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>  <span class="c1">// error: Color::red is not an int</span>
<span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>         <span class="c1">// error: 2 is not a color </span>

<span class="n">Color</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Color</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// OK, explicit cast</span>
<span class="n">Color</span> <span class="n">x</span> <span class="p">{</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// OK</span>
</code></pre></div></div> <p>We can define operators for an <code class="language-plaintext highlighter-rouge">enum class</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Traffic_light</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="n">Traffic_light</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="k">enum</span> <span class="n">Traffic_light</span><span class="p">;</span> <span class="c1">// avoid repetition of the enumeration name</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">green</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span><span class="o">=</span><span class="n">yellow</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">yellow</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span><span class="o">=</span><span class="n">red</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">red</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span><span class="o">=</span><span class="n">green</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A “plain” <code class="language-plaintext highlighter-rouge">enum</code> (i.e., without <code class="language-plaintext highlighter-rouge">class</code>) exposes its enumerators directly into the surrounding scope and allows implicit conversion to and from integers. While this makes them less well behaved, they remain common in modern code due to their long-standing presence in both C++ and C.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">green</span><span class="p">;</span> <span class="c1">// col gets the value 1</span>
</code></pre></div></div> <h3 id="unions">Unions</h3> <p>A <code class="language-plaintext highlighter-rouge">union</code> is a <code class="language-plaintext highlighter-rouge">struct</code> in which all memebers are allocated at the same address so that the <code class="language-plaintext highlighter-rouge">union</code> occupies only as much space as its largest member.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">Value</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>The language dones’t keep track of which kind of value is held by a <code class="language-plaintext highlighter-rouge">union</code>, so the programmer must do that:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Type</span> <span class="p">{</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">num</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Entry</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">Type</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">Value</span> <span class="n">v</span><span class="p">;</span><span class="c1">// use v.p if t==Type::ptr; use v.i if t==Type::num</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">pe</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">==</span> <span class="n">Type</span><span class="o">:</span><span class="n">num</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Maintaing the correspondence between a <em>type field</em>, sometimes called a <em>discriminant</em> or a <em>tag</em>, (here, <code class="language-plaintext highlighter-rouge">t</code>) and the type held in a <code class="language-plaintext highlighter-rouge">union</code> is error-prone.</p> <p>To avoid this, encapsulate the logic in a class, or better, use a <code class="language-plaintext highlighter-rouge">variant</code> from the standard library.</p> <p>A <code class="language-plaintext highlighter-rouge">variant</code> hold one value from a set of types:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Entry</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">variant</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">pe</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">))</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>For many uses, a <code class="language-plaintext highlighter-rouge">variant</code> is simpler and safer to use than a <code class="language-plaintext highlighter-rouge">union</code>.</p> <h2 id="3-modularity">3 Modularity</h2> <p>C++ represents interfaces using declarations. A <strong>declaration</strong> specifies everything needed to use a function or a type:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</code></pre></div></div> <p>The function’s <strong>definition</strong> can be provided elsewhere:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span>  <span class="c1">// definition of sqrt()</span>
<span class="p">{</span>
  <span class="c1">// ... algorithm</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="separate-compilation">Separate Compilation</h3> <h4 id="header-files">Header Files</h4> <p>We place declarations that specify the interface to a piece of code we consider a module in a file with a name indicating its intended use — a <strong>header file</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Vector.h</span>

<span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">);</span>
  <span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Users then <code class="language-plaintext highlighter-rouge">#include</code> that file to access the interface:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// user.cpp</span>

<span class="cp">#include</span> <span class="cpf">"Vector.h"</span><span class="cp">
</span>
<span class="kt">double</span> <span class="nf">sqrt_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>To help the compiler ensure consistency, the <code class="language-plaintext highlighter-rouge">.cpp</code> file providing the implementation of <code class="language-plaintext highlighter-rouge">Vector</code> also includes the <code class="language-plaintext highlighter-rouge">.h</code> file:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Vector.cpp</span>

<span class="cp">#include</span> <span class="cpf">"Vector.h"</span><span class="cp">
</span>
<span class="n">Vector</span><span class="o">::</span><span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">]},</span> <span class="n">sz</span><span class="p">{</span><span class="n">s</span><span class="p">}</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div> <p>The code in <code class="language-plaintext highlighter-rouge">use.cpp</code> and <code class="language-plaintext highlighter-rouge">Vector.cpp</code> shares the <code class="language-plaintext highlighter-rouge">Vector</code> interface from <code class="language-plaintext highlighter-rouge">Vector.h</code>, but the two files are otherwise independent and can be compiled separately.</p> <p>A <code class="language-plaintext highlighter-rouge">.cpp</code> file compiled by itself (including the <code class="language-plaintext highlighter-rouge">h</code> files it <code class="language-plaintext highlighter-rouge">#include</code>s) is called a <strong>translation unit</strong>.</p> <p>The use of header files and <code class="language-plaintext highlighter-rouge">#include</code> is a very old way of simulating modularity with significant disadvantages.</p> <ul> <li> <p><strong>Compilation time</strong>: If <code class="language-plaintext highlighter-rouge">header.h</code> is included in 101 translation units, its contents will be processed by the compiler 101 times.</p> </li> <li> <p><strong>Order dependencies</strong>: The order in which headers are included can affect the meaning of the code (e.g., macros or conflicting declarations).</p> </li> <li> <p><strong>Inconsistency</strong>: Slight differences in duplicated declarations across files can lead to crashes or subtle bugs.</p> </li> <li> <p><strong>Transitivity</strong>: All code needed to express a declaration in a header must be included there, leading to code bloat as headers include other headers.</p> </li> </ul> <h4 id="modules">Modules</h4> <p>C++20 introduces <code class="language-plaintext highlighter-rouge">module</code> to provide proper modularity:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">module</span> <span class="n">Vector</span><span class="p">;</span>

<span class="k">export</span> <span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">);</span>
  <span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Vector</span><span class="o">::</span><span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
  <span class="o">:</span><span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">]},</span> <span class="n">sz</span><span class="p">{</span><span class="n">s</span><span class="p">}</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">//...</span>

<span class="k">export</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div> <p>This defines a <code class="language-plaintext highlighter-rouge">module</code> named <code class="language-plaintext highlighter-rouge">Vector</code>, which exports the <code class="language-plaintext highlighter-rouge">Vector</code> class, its member functions, and a non-member function defining opertor <code class="language-plaintext highlighter-rouge">==</code>.</p> <p>You can <code class="language-plaintext highlighter-rouge">import</code> it where needed:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// user.cpp</span>

<span class="k">import</span> <span class="n">Vector</span><span class="p">;</span>

<span class="kt">double</span> <span class="nf">sqrt_sum</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Advantages of modules:</p> <ul> <li>A module is compiled once, not in every translation unit that uses it.</li> <li>Modules can be imported in any order without affecting behavior.</li> <li>Importing something into a module does not implicitly expose it to users of the module — imports are not transitive.</li> </ul> <p>Modules also simplify implementation hiding: only <code class="language-plaintext highlighter-rouge">export</code>ed declarations are accessible to users.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">module</span> <span class="n">vector_printer</span><span class="p">;</span>

<span class="k">import</span> <span class="n">std</span><span class="p">;</span>

<span class="k">export</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span>  <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'}'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>By importing this module, we don’t suddenly gain access to all of the standard library.</p> <h3 id="namespaces">Namespaces</h3> <p>C++ provides <strong>namespaces</strong> to group related declarations and prevent name collisions:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">My_code</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">complex</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">};</span>

  <span class="n">complex</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">complex</span><span class="p">);</span>
  <span class="c1">// ...</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">My_code</span><span class="o">::</span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">complex</span> <span class="n">z1</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
  <span class="k">auto</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'{'</span> <span class="o">&lt;&lt;</span> <span class="n">z2</span><span class="p">.</span><span class="n">real</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">','</span> <span class="o">&lt;&lt;</span> <span class="n">z2</span><span class="p">.</span><span class="n">imag</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">My_code</span><span class="o">::</span><span class="n">main</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>To access a name in another namespace, qualify it with the namespace name (e.g., <code class="language-plaintext highlighter-rouge">std::cout</code>, <code class="language-plaintext highlighter-rouge">My_code::main</code>).</p> <p>If this becomes tedious, use a <strong>using-declaration</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">my_code</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">other</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <p>To access all names in a namespace, use a <strong>using-directive</strong>: <code class="language-plaintext highlighter-rouge">using namespace std;</code>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">module</span> <span class="n">vector_printer</span><span class="p">;</span>

<span class="k">import</span> <span class="n">std</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">export</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'}'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This brings all names into the current scope but can cause name clashes, so use with caution.</p> <h3 id="function-arguments-and-return-values">Function Arguments and Return Values</h3> <p>Function calls are the primary and recommended way to pass information between program parts. Key considerations:</p> <ul> <li>Is the object copied or shared?</li> <li>If shared, is it mutable?</li> <li>Is the object moved, leaving an “empty” object behind?</li> </ul> <p>The deault behavior of both argument passing and value return is “make a copy”, but many copies can implicitly be optimized to moves.</p> <h4 id="argument-passing">Argument Passing</h4> <p>We typically pass small objects by-value and larger ones by-reference. As a rule of thumb, an object is considered “small” if its size is not larger than “2 to 3 pointers”. When passing large objects for performance reasons, but without the intent to modify them, we pass them by-<code class="language-plaintext highlighter-rouge">const</code>-reference.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span> <span class="n">fib</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">fib</span><span class="p">);</span>
</code></pre></div></div> <h4 id="value-return">Value Return</h4> <p>Returning by value is the default and often efficient. Return by reference only when we want to grant a caller access to something that is not local to the function.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// ...</span>
  <span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span> <span class="k">return</span> <span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// return reference to ith element</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">i</code>th element of a <code class="language-plaintext highlighter-rouge">Vector</code> exists independently of the call of the subscript operator, so we can returen a reference to it.</p> <p>Avoid returning references to local variables:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">&amp;</span> <span class="n">bad</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// bad: return a reference to the local variable x</span>
<span class="p">}</span>
</code></pre></div></div> <p>All major C++ compilers will catch the obvious error in <code class="language-plaintext highlighter-rouge">bad()</code>.</p> <p>For large return values, C++ uses <strong>move semantics</strong> or <strong>copy elision</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Matrix</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">res</span><span class="p">;</span>
  <span class="c1">// ... for all res[i,j], res[i,j]=x[i,j]+y[i,j]</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Matrix</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>
<span class="n">Matrix</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">;</span> <span class="c1">// not copy</span>
</code></pre></div></div> <p>Instead of copying, we provide <code class="language-plaintext highlighter-rouge">Matrix</code> with a <strong>move constructor</strong> that can efficiently transfer its contents out of <code class="language-plaintext highlighter-rouge">operator+()</code>. Even if a move constructor isn’t explicitly defined, the compiler can often optimize away the copy through <strong>copy elision</strong>, constructing the Matrix directly at its destination.</p> <h4 id="return-type-deduction">Return Type Deduction</h4> <p>C++ can deduce return types using <code class="language-plaintext highlighter-rouge">auto</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">;</span> <span class="p">}</span> 
<span class="c1">// auto means "deduce the return type"</span>
</code></pre></div></div> <p>You can also use the <strong>suffix return type</strong> syntax:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">d</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// auto means "the return type will be mentioned later or be deduced"</span>
</code></pre></div></div> <h4 id="structured-binding">Structured Binding</h4> <p>The mechanism for giving local names to members of a class object.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Entry</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Entry</span> <span class="nf">read_entry</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">};</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">read_entry</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{"</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">{s,i}</code> is used to construct the <code class="language-plaintext highlighter-rouge">Entry</code> return value. Similarly, we can “unpack” an <code class="language-plaintext highlighter-rouge">Entry</code>’s members into local variables:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_entry</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{"</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div> <h2 id="6-essential-operations">6 Essential Operations</h2> </div> </article> </div> </div> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="" integrity="" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?24942e121cfda2aba3d081e7fdf38369"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1H8VDR0JJ"></script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>