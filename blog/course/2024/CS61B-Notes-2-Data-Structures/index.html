<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="SsJLQVCu35H-wMDMbIHpAv2Y65KagLlcfArj6qaf0CY"> <meta name="msvalidate.01" content="1E11C54B5E73180465BA7047C6DD4D83"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> CS 61B (Sp21) Notes 2, Data Structures | Na Sang </title> <meta name="author" content="Na Sang"> <meta name="description" content="Asymptotics, Set, Map, Disjoint Sets, Priority Queues, Tree, Graph "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?b8ef20a79f5306f65378fcc706e98671" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%98%80%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nasang.github.io/blog/course/2024/CS61B-Notes-2-Data-Structures/"> <link rel="stylesheet" href="https://unpkg.com/@coreui/icons/css/brand.min.css"> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Na</span> Sang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">CS 61B (Sp21) Notes 2, Data Structures</h1> <p class="post-meta"> Created in October 23, 2024   ·   34 min read </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/data-structures"> <i class="fa-solid fa-hashtag fa-sm"></i> data structures</a>   ·   <a href="/blog/category/course"> <i class="fa-solid fa-tag fa-sm"></i> course</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="13-asymptotics-i">13. Asymptotics I</h2> <p>Our goal is to somehow <strong><u>characterize the runtimes</u></strong> of two functions. Characterization should be (1) <strong>simple</strong> and <strong>mathematically rigorous</strong>; and (2) <strong>demonstrate superiority</strong> of one over the other.</p> <h3 id="asymptotic-analysis">Asymptotic Analysis</h3> <h4 id="scaling-matters">Scaling Matters</h4> <p>In most cases, we care only about <strong><u>asymptotic behavior</u></strong>, i.e. what happens for very large $N$.</p> <p>Algorithms which scale well (e.g. look like lines) have better asymptotic runtime behavior than algorithms that scale relatively poorly (e.g. look like parabolas). We’ll informally refer to the “shape” of a runtime function as its <strong>order of growth</strong> (will formalize soon).</p> <ul> <li>Often determines whether a problem can be solved at all.</li> </ul> <h4 id="computing-worst-case-order-of-growth-tedious-approach">Computing Worst Case Order of Growth (Tedious Approach)</h4> <ul> <li>Construct a table of exact counts of all possible operations.</li> </ul> <p><img src="/assets/img/cs61b/13/count.png" alt="count" width="550" loading="lazy"></p> <ul> <li>Convert table into worst case order of growth using 4 simplifications: <ol> <li>Only consider the worst case.</li> <li>Pick a representative operation (a.k.a. the cost model).</li> <li>Ignore lower order terms.</li> <li>Ignore multiplicative constants.</li> </ol> </li> </ul> <p><img src="/assets/img/cs61b/13/simplify.png" alt="simlipy" width="500" loading="lazy"></p> <h4 id="computing-worst-case-order-of-growth-simplified-approach">Computing Worst Case Order of Growth (Simplified Approach)</h4> <ul> <li>Choose a representative operation to count (a.k.a. cost model).</li> <li>Figure out the order of growth for the count of the representative operation by either: <ul> <li>Making an exact count, then discarding the unnecessary pieces.</li> <li>Using intuition and inspection to determine order of growth (only possible with lots of practice).</li> </ul> </li> </ul> <h3 id="asymptotic-notation">Asymptotic Notation</h3> <h4 id="big-theta-aka-order-of-growth">Big-Theta (a.k.a. Order of Growth)</h4> <p>For some function $R(N)$ with <strong>order of growth</strong> $f(N)$, we write that $R(N) \in \Theta(f(N))$. There exists some positive constants $k_1$, $k_2$ such that $k_1 \cdot f(N) \leq R(N) \leq k_2 \cdot f(N)$, for all values $N$ greater than some $N_0$ (a very large $N$).</p> <p><img src="/assets/img/cs61b/13/Big-Theta.png" alt="Big-Theta" width="450" loading="lazy"> <em><a href="https://sp19.datastructur.es/materials/demos/asymptotics.html?rN=4*N%5E2+40*sin(N)&amp;fN=N%5E2&amp;k1=3&amp;k2=5&amp;maxN=15&amp;maxY=1000" rel="external nofollow noopener" target="_blank">Visualization</a></em></p> <h4 id="big-o">Big-O</h4> <p>$R(N) \in O(f(N))$ means that there exists positive constant $k_2$ such that $R(N) \leq k_2 \cdot f(N)$, for all values of $N$ greater than some $N_0$ (a very large $N$).</p> <p><img src="/assets/img/cs61b/13/Big-O.png" alt="Big-O" width="450" loading="lazy"> <em><a href="https://sp19.datastructur.es/materials/demos/asymptotics.html?rN=4*N%5E2+40*sin(N)&amp;fN=N%5E4&amp;k1=0&amp;k2=5&amp;maxN=15&amp;maxY=1000" rel="external nofollow noopener" target="_blank">Visualization</a></em></p> <p>Whereas $\Theta$ can informally be thought of as something like “equals”, $O$ can be thought of as “less than or equal”.</p> <h3 id="summary">Summary</h3> <p>Given a piece of code, we can express its runtime as a function $R(N)$, where $N$ is a property of the input of the function often representing the <strong>size</strong> of the input. Rather than finding the exact value of $R(N)$ , we only worry about finding the <strong>order of growth</strong> of $R(N)$. One approach (not universal):</p> <ul> <li>Choose a representative operation</li> <li>Let $C(N)$ be the count of how many times that operation occurs as a function of $N$</li> <li>Determine order of growth $f(N)$ for $C(N)$, i.e. $C(N) \in \Theta(f(N))$</li> <li>Often (but not always) we consider the worst case count</li> <li>If operation takes constant time, then $R(N) \in \Theta(f(N))$</li> <li>Can use $O$ as an alternative for $\Theta$. $O$ is used for upper bounds.</li> </ul> <h2 id="14-disjoint-sets">14. Disjoint Sets</h2> <h3 id="dynamic-connectivity-problem">Dynamic Connectivity Problem</h3> <p>Deriving the “Disjoint Sets” data structure for solving the “Dynamic Connectivity” problem. The Disjoint Sets data structure has two operations:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">connect(x, y)</code>: Connects <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>.</li> <li> <code class="language-plaintext highlighter-rouge">isConnected(x, y)</code>: Returns <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are connected. Connections can be transitive, i.e. they don’t need to be direct.</li> </ul> <p>Goal: Design an efficient <code class="language-plaintext highlighter-rouge">DisjointSets</code> implementation. <img src="/assets/img/cs61b/14/disjoint_set_interface.png" alt="disjoint_set_interface" width="500" loading="lazy"></p> <p>For each item, its <strong>connected component</strong> is the set of all items that are connected to that item. Model connectedness in terms of <u>sets</u> to keep track of which connected component each item belongs to.</p> <p><img src="/assets/img/cs61b/14/connected_components.png" alt="connected_components" width="500" loading="lazy"></p> <h3 id="quick-find">Quick Find</h3> <p>Use an array of integers, where <code class="language-plaintext highlighter-rouge">i</code>th entry gives set number (a.k.a. “id”) of item <code class="language-plaintext highlighter-rouge">i</code>.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">connect(x, y)</code>: Change entries that equal <code class="language-plaintext highlighter-rouge">id[x]</code> to <code class="language-plaintext highlighter-rouge">id[y]</code>.</li> <li> <code class="language-plaintext highlighter-rouge">isConnected(x, y)</code>: Check if <code class="language-plaintext highlighter-rouge">id[x]</code> equals <code class="language-plaintext highlighter-rouge">id[y]</code>.</li> </ul> <p><img src="/assets/img/cs61b/14/quick_find.png" alt="quick_find" width="500" loading="lazy"></p> <p><code class="language-plaintext highlighter-rouge">QuickFind</code> is too slow for practical use: Connecting two items takes $N$ time.</p> <h3 id="quick-union">Quick Union</h3> <p>How could we change our set representation so that combining two sets into their union requires changing <strong>one</strong> value? Assign each item a <code class="language-plaintext highlighter-rouge">parent</code> (instead of an <code class="language-plaintext highlighter-rouge">id</code>). Results in a tree-like shape. Note: <u>for root items, we have item’s parent as itself.</u></p> <ul> <li> <code class="language-plaintext highlighter-rouge">connect(x, y)</code>: make <code class="language-plaintext highlighter-rouge">root(x)</code> into a child of <code class="language-plaintext highlighter-rouge">root(y)</code>.</li> <li> <code class="language-plaintext highlighter-rouge">isConnected(x, y)</code>: Check if <code class="language-plaintext highlighter-rouge">root(x)</code> equals <code class="language-plaintext highlighter-rouge">root(y)</code>.</li> </ul> <p><img src="/assets/img/cs61b/14/quick_union.png" alt="quick_union" width="500" loading="lazy"></p> <p><img src="/assets/img/cs61b/14/quick_union_connect.png" alt="quick_union_connect" width="500" loading="lazy"> <em>connect(5, 2): Make root(5) into a child of root(2)</em></p> <p>Compared to <code class="language-plaintext highlighter-rouge">QuickFind</code>, we have to climb up a tree. Tree can get too tall and <code class="language-plaintext highlighter-rouge">root(x)</code> becomes expensive. <strong>Things would be fine if we just keep our tree balanced.</strong></p> <h3 id="weighted-quick-union">Weighted Quick Union</h3> <p>Modify quick-union to avoid tall trees. Track tree <strong>size</strong> (number of elements), and always <u>link root of smaller tree to larger tree</u>.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">connect(x, y)</code>: create a separate <code class="language-plaintext highlighter-rouge">size</code> array to keep track of sizes. make <code class="language-plaintext highlighter-rouge">root(x)</code> into a child of <code class="language-plaintext highlighter-rouge">root(y)</code>, if <code class="language-plaintext highlighter-rouge">size[root(x)]</code> is smaller than <code class="language-plaintext highlighter-rouge">size[root(y)]</code>, or vice versa.</li> <li> <code class="language-plaintext highlighter-rouge">isConnected(x, y)</code>: Check if <code class="language-plaintext highlighter-rouge">root(x)</code> equals <code class="language-plaintext highlighter-rouge">root(y)</code>.</li> </ul> <p><img src="/assets/img/cs61b/14/choice_of_root.png" alt="choice_of_root" width="500" loading="lazy"></p> <h3 id="path-compression">Path Compression</h3> <p>When we do <code class="language-plaintext highlighter-rouge">isConnected(x, y)</code>, tie all nodes seen to the root.</p> <p><img src="/assets/img/cs61b/14/path_compression_1.png" alt="path_compression_1" width="450" loading="lazy"></p> <p><img src="/assets/img/cs61b/14/path_compression_2.png" alt="path_compression_2" width="450" loading="lazy"></p> <p><img src="/assets/img/cs61b/14/path_compression_3.png" alt="path_compression_3" width="450" loading="lazy"></p> <h2 id="16-adts-sets-maps-bsts">16. ADTs, Sets, Maps, BSTs</h2> <h3 id="abstract-data-types">Abstract Data Types</h3> <p>An <strong>Abstract Data Type (ADT)</strong> is defined only by its operations, not by its implementation. The built-in <a href="https://docs.oracle.com/javase/8/docs/api/java/util/package-summary.html" rel="external nofollow noopener" target="_blank"><strong>java.util</strong></a> package provides a number of useful:</p> <ul> <li> <strong>Interfaces</strong>: ADTs (List, Set, Map, etc.) and other stuff.</li> <li> <strong>Implementations</strong>: Concrete classes you can use.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div> <p><img src="/assets/img/cs61b/16/Java_utils.png" alt="java" width="550" loading="lazy"> <em>Common interfaces in Java and their implementations</em></p> <p>This lecture is about the basic ideas behind the <code class="language-plaintext highlighter-rouge">TreeSet</code> and <code class="language-plaintext highlighter-rouge">TreeMap</code>.</p> <h3 id="binary-search-trees">Binary Search Trees</h3> <h4 id="derivation">Derivation</h4> <p>For the <strong>ordered linked list</strong> set implementation below, <code class="language-plaintext highlighter-rouge">contains</code> and <code class="language-plaintext highlighter-rouge">add</code> take worst case linear time, i.e. $\Theta(N)$. Fundamental Problem: Slow search, even though it’s in order.</p> <p><img src="/assets/img/cs61b/16/ordered_linked_list.png" alt="ordered_linked_list" width="550" loading="lazy"></p> <p>In <strong>binary search</strong>, we know the list is sorted, so we can use this information to narrow our search. <u>Applying binary search to a linked list</u> might seem challenging at first. We need to traverse all the way to the middle to check the element there, which would take linear time.</p> <p>However, we can optimize this process. One way is to <strong>keep a reference to the middle node</strong>. This allows us to reach the middle in constant time. Additionally, if we <strong>reverse the nodes’ pointers</strong>, we can traverse both the left and right halves of the list, effectively halving our runtime. We can further optimize by <strong>adding pointers to the middle of each recursive half like so</strong>.</p> <p><img src="/assets/img/cs61b/16/halved.png" alt="halved" width="550" loading="lazy"> <em>A linked list with a middle pointer</em></p> <p><img src="/assets/img/cs61b/16/better.png" alt="better" width="550" loading="lazy"> <em>A linked list with recursive middle pointers is a binary tree</em></p> <p>Now, if you stretch this structure vertically, you will see a tree. This specific tree is called a <strong>binary tree</strong> because each juncture splits in 2.</p> <h4 id="bst-definition">BST Definition</h4> <p>A <strong>binary search tree</strong> is a rooted binary tree with the BST property, i.e., For every node <code class="language-plaintext highlighter-rouge">X</code> in the tree: every key in the left subtree is less than <code class="language-plaintext highlighter-rouge">X</code>’s key, and every key in the right subtree is greater than <code class="language-plaintext highlighter-rouge">X</code>’s key.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">BST</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">;</span>
  <span class="kd">private</span> <span class="no">BST</span> <span class="n">left</span><span class="o">;</span>
  <span class="kd">private</span> <span class="no">BST</span> <span class="n">right</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">BST</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="no">BST</span> <span class="n">left</span><span class="o">,</span> <span class="no">BST</span> <span class="nc">Right</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nf">BST</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="contains">Contains</h4> <p>To find a searchKey in a BST, we employ binary search, which is made easy due to the BST property.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="no">BST</span> <span class="nf">find</span><span class="o">(</span><span class="no">BST</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">sk</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="no">T</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">key</span><span class="o">))</span>
    <span class="k">return</span> <span class="no">T</span><span class="o">;</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sk</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sk</span><span class="o">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">sk</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>The runtime to complete a search on a “bushy” BST in the worst case is $\Theta(\log N)$, where $N$ is the number of nodes.</p> <h4 id="insert">Insert</h4> <p>We <strong>always</strong> insert at a leaf node.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="no">BST</span> <span class="nf">insert</span><span class="o">(</span><span class="no">BST</span> <span class="no">T</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">ik</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="no">T</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">BST</span><span class="o">(</span><span class="n">ik</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">ik</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="no">T</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">insert</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">ik</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ik</span> <span class="o">&gt;</span> <span class="no">T</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="no">T</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">insert</span><span class="o">(</span><span class="no">T</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">ik</span><span class="o">);</span>
  <span class="k">return</span> <span class="no">T</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="deletion">Deletion</h4> <p>Deleting from a binary tree is a little bit more complicated because whenever we delete, we need to make sure we <strong>reconstruct the tree and still maintain its BST property</strong>. Let’s break this problem down into three categories:</p> <ul> <li>the node we are trying to delete has no children</li> <li>has 1 child</li> <li>has 2 children</li> </ul> <p>#####: Key with no Children We can just <u>delete its parent pointer</u> and the node will eventually be swept away by the garbage collector.</p> <p>#####: Key with one Child The child maintains the BST property with the parent of the node because the property is recursive to the right and left subtrees. Therefore, we can just <u>reassign the parent's child pointer to the node's child</u> and the node will eventually be garbage collected.</p> <p>Example: <strong>delete(“flat”)</strong></p> <p><img src="/assets/img/cs61b/16/del_1_child.png" alt="one child" width="300" loading="lazy"></p> <p>#####: Key with two Children (Hibbard) If the node has two children, the process becomes a little more complicated because we can’t just assign one of the children to be the new root. This might break the BST property. Instead, we <u>choose a new node to replace the deleted one</u>. We know that the new node must:</p> <ul> <li>be &gt; than everything in left subtree.</li> <li>be &lt; than everything right subtree.</li> </ul> <p>Example: <strong>delete(“dog”)</strong></p> <p><img src="/assets/img/cs61b/16/del_2_children.png" alt="two children" width="300" loading="lazy"></p> <p>Choose either <u>predecessor</u> (<code class="language-plaintext highlighter-rouge">cat</code>, the right-most node in the left subtree) or <u>successor</u> (<code class="language-plaintext highlighter-rouge">elf</code>, the left-most node in the right subtree). Delete <code class="language-plaintext highlighter-rouge">cat</code> or <code class="language-plaintext highlighter-rouge">elf</code>, and stick new copy in the root position. This deletion guaranteed to be either case 1 or 2. This strategy is known as <strong>Hibbard deletion</strong>.</p> <h3 id="sets-and-maps">Sets and Maps</h3> <h4 id="set">Set</h4> <p>Can think of the BST below as representing a Set:</p> <ul> <li>{mo, no, sumomo, uchi, momo}</li> </ul> <p><img src="/assets/img/cs61b/16/set.png" alt="set" width="450" loading="lazy"></p> <h4 id="map">Map</h4> <p>To represent maps, just have each BST node store key/value pairs.</p> <p><img src="/assets/img/cs61b/16/map.png" alt="map" width="450" loading="lazy"></p> <p>Note: No efficient way to look up by value.</p> <ul> <li>Example: Cannot find all the keys with value = 1 without iterating over <strong>ALL</strong> nodes. This is fine.</li> </ul> <h3 id="summary-1">Summary</h3> <ul> <li>Abstract data types (ADTs) are defined in terms of operations, not implementation. <ul> <li>Several useful ADTs: Disjoint Sets, Map, Set, List.</li> </ul> </li> <li>Java provides <code class="language-plaintext highlighter-rouge">Map</code>, <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">List</code> interfaces, along with several implementations.</li> <li>We’ve seen two ways to implement a Set (or Map): <ul> <li>ArraySet: $\Theta(N)$ operations in the worst case.</li> <li>BST: $\Theta(\log N)$ operations if tree is balanced.</li> </ul> </li> <li>BST Implementations: <ul> <li>Search and insert are straightforward (but insert is a little tricky).</li> <li>Deletion is more challenging. Typical approach is “Hibbard deletion”.</li> </ul> </li> </ul> <h2 id="trees">Trees)</h2> <h3 id="binary-search-trees-1">Binary Search Trees</h3> <h4 id="bst-height">BST Height</h4> <p>BST height is all four of these:</p> <ul> <li>$O(N)$.</li> <li>$\Theta(\log N)$ in the best case (“bushy”).</li> <li>$\Theta(N)$ in the worst case (“spindly”).</li> <li>$O(N^2)$.</li> </ul> <p><img src="/assets/img/cs61b/17/BST.png" alt="BST" width="550" loading="lazy"> <em>Trees range from best-case “bushy” to worst-case “spindly”</em></p> <p>Difference is dramatic!</p> <h4 id="worst-case-performance">Worst Case Performance</h4> <p><strong>Height and Depth</strong></p> <ul> <li>The <strong>depth</strong> of a node is how far it is from the root, e.g. <code class="language-plaintext highlighter-rouge">depth(g)</code> = 2.</li> <li>The <strong>height</strong> of a tree is the depth of its deepest leaf, e.g. <code class="language-plaintext highlighter-rouge">height(T)</code> = 4.</li> </ul> <p><img src="/assets/img/cs61b/17/height_and_depth.png" alt="height_and_depth" width="550" loading="lazy"></p> <ul> <li>The <strong>average depth</strong> of a tree is the average depth of a tree’s nodes. <ul> <li>(0x1 + 1x2 + 2x4 + 3x6 + 4x1)/(1+2+4+6+1) = 2.35</li> </ul> </li> </ul> <p><strong>Runtime</strong></p> <ul> <li>The height of a tree determines <u>the worst case runtime to find a node</u>. <ul> <li>Example: Worst case is <code class="language-plaintext highlighter-rouge">contains(s)</code>, requires 5 comparisons (height + 1).</li> </ul> </li> <li>The “average depth” determines <u>the average case runtime to find a node</u>. <ul> <li>Example: Average case is 3.35 comparisons (average depth + 1).</li> </ul> </li> </ul> <p><strong>Nice Property</strong></p> <p>Random trees have $\Theta(\log N)$ average depth and height.</p> <ul> <li>Good news: BSTs have great performance if we insert items randomly. Performance is $\Theta(\log N)$ per operation.</li> <li>Bad News: We can’t always insert our items in a random order.</li> </ul> <h3 id="b-trees">B-Trees</h3> <h4 id="splitting-juicy-nodes">Splitting Juicy Nodes</h4> <h5 id="avoiding-imbalance-through-overstuffing">Avoiding Imbalance through Overstuffing</h5> <blockquote class="prompt-tip"> <p>If we could simply avoid adding new leaves in our BST, the height would never increase.</p> </blockquote> <p>Instead of adding a new node upon insertion, we simply stack the new value into an existing leaf node at the appropriate location. Suppose we add <code class="language-plaintext highlighter-rouge">17</code>, <code class="language-plaintext highlighter-rouge">18</code>:</p> <p><img src="/assets/img/cs61b/17/overstuffing.png" alt="overstuffing" width="600" loading="lazy"> <em>Avoid new leaves by “overstuffing” the leaf nodes</em></p> <h5 id="moving-items-up">Moving Items Up</h5> <blockquote class="prompt-danger"> <p>Height is balanced, but we have a new problem: Leaf nodes can get too juicy.</p> </blockquote> <p>We can set a limit $L$ on the number of items, say $L=3$. If any node has more than $L$ items, give an item to parent. Which one? Let’s say (arbitrarily) the left-middle.</p> <p><img src="/assets/img/cs61b/17/move_up.png" alt="move_up" width="550" loading="lazy"> <em>Moving 17 from a leaf node to its parent</em></p> <p>However, this runs into the issue that our binary search property is no longer preserved: <code class="language-plaintext highlighter-rouge">16</code> is to the right of <code class="language-plaintext highlighter-rouge">17</code>. As such, we need a second fix: split the overstuffed node into ranges: $(-\infty,15)$, $(15, 17)$ and $(17, +\infty)$. Parent node now has three children.</p> <p><img src="/assets/img/cs61b/17/split.png" alt="split" width="250" loading="lazy"> <em>Splitting the children of an overstuffed node</em></p> <h5 id="chain-reaction-splitting">Chain Reaction Splitting</h5> <p>Suppose we add <code class="language-plaintext highlighter-rouge">25</code>, <code class="language-plaintext highlighter-rouge">26</code>:</p> <p><img src="/assets/img/cs61b/17/chain_1.png" alt="chain_1" width="600" loading="lazy"></p> <p>In the case when our root is above the limit, we are forced to increase the tree height.</p> <p><img src="/assets/img/cs61b/17/root.png" alt="root" width="550" loading="lazy"></p> <h4 id="b-tree-terminology">B-Tree Terminology</h4> <blockquote> <p>The origin of “B-tree” has never been explained by the authors. As we shall see, “balanced,” “broad,” or “bushy” might apply. Others suggest that the “B” stands for Boeing. Because of his contributions, however, it seems appropriate to think of B-trees as “Bayer”-trees. – Douglas Corner (The Ubiquitous B-Tree)</p> </blockquote> <p>Observe that our new splitting-tree data structure has <u>perfect balance</u>. If we split the root, every node is pushed down by one level. If we split a leaf or internal node, the height does not change. There is never a change that results in imbalance.</p> <p>The real name for this data structure is a <strong>B-Tree</strong>. B-Trees with a limit of 3 items per node are also called 2-3-4 trees or 2-4 trees (a node can have 2, 3, or 4 children). Setting a limit of 2 items per node results in a 2-3 tree.</p> <p>B-Trees are used mostly in two specific contexts:</p> <ul> <li>Small $L$ ($L=2$ or $L=3$): <ul> <li>Used as a conceptually simple balanced search tree (as today).</li> </ul> </li> <li>$L$ is very large (say thousands). <ul> <li>Used in practice for databases and filesystems (i.e. systems with very large records).</li> </ul> </li> </ul> <h4 id="b-tree-invariants">B-Tree Invariants</h4> <p>Because of the way B-Trees are constructed, we get two nice invariants:</p> <ul> <li>All leaves must be the same distance from the root.</li> <li>A non-leaf node with $k$ items must have exactly $k+1$ children.</li> </ul> <h4 id="worst-case-performance-1">Worst Case Performance</h4> <p>Let $L$ be the maximum items per node. Based on our invariants, the maximum height must be somewhere between $\log_{L+1}(N)$ and $\log_2(N)$.</p> <ul> <li>Largest possible height is all non-leaf nodes have 1 item.</li> </ul> <p><img src="/assets/img/cs61b/17/worst_case.png" alt="worst_case" width="250" loading="lazy"></p> <ul> <li>Smallest possible height is all nodes have $L$ items.</li> </ul> <p><img src="/assets/img/cs61b/17/best_case.png" alt="best_case" width="500" loading="lazy"></p> <p>Overall height is therefore $\Theta(\log N)$.</p> <p><strong>Runtime for <code class="language-plaintext highlighter-rouge">contains</code></strong></p> <p>In the worst case, we have to examine up to $L$ items per node. We know that height is logarithmic, so the runtime of <code class="language-plaintext highlighter-rouge">contains</code> is bounded by $O(L \log N)$. Since $L$ is a constant, we can drop the multiplicative factor, resulting in a runtime of $O(\log N)$.</p> <p><strong>Runtime for <code class="language-plaintext highlighter-rouge">add</code></strong></p> <p>A similar analysis can be done for <code class="language-plaintext highlighter-rouge">add</code>, except we have to consider the case in which we must split a leaf node. Since the height of the tree is $O(\log N)$, at worst, we do $\log N$ split operations (cascading from the leaf to the root). This simply adds an additive factor of $\log N$ to our runtime, which still results in an overall runtime of $O(\log N)$.</p> <h3 id="summary-2">Summary</h3> <p>BSTs have best case height $\Theta(\log N)$, and worst case height $\Theta(N)$. B-Trees are a modification of the binary search tree that avoids $\Theta(N)$ worst case.</p> <ul> <li>Nodes may contain between 1 and $L$ items.</li> <li> <code class="language-plaintext highlighter-rouge">contains</code> works almost exactly like a normal BST.</li> <li> <code class="language-plaintext highlighter-rouge">add</code> works by adding items to existing leaf nodes. <ul> <li>If nodes are too full, they split.</li> </ul> </li> <li>Resulting tree has perfect balance. Runtime for operations is $O(\log N)$.</li> <li>B-trees are more complex, but they can efficiently handle any <strong>insertion order</strong>.</li> </ul> <h2 id="red-black-trees">Red Black Trees</h2> <h3 id="tree-rotation">Tree Rotation</h3> <h4 id="bsts">BSTs</h4> <p>Suppose we have a BST with the numbers <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>. Five possible BSTs.</p> <ul> <li>The specific BST you get is based on the insertion order.</li> <li>More generally, for $N$ items, there are <a href="https://en.wikipedia.org/wiki/Catalan_number" rel="external nofollow noopener" target="_blank">Catalan(N)</a> different BSTs.</li> </ul> <p><img src="/assets/img/cs61b/18/BSTs.png" alt="BSTs" width="550" loading="lazy"></p> <p>Given any BST, it is possible to move to a different configuration using “rotation”.</p> <ul> <li>In general, can move from any configuration to any other in 2n - 6 rotations (see <a href="https://www.cs.cmu.edu/~sleator/papers/rotation-distance.pdf" rel="external nofollow noopener" target="_blank">Rotation Distance, Triangulations, and Hyperbolic Geometry</a> or <a href="https://medium.com/@liuamyj/its-triangles-all-the-way-down-part-1-17f932f4c438" rel="external nofollow noopener" target="_blank">Amy Liu</a>).</li> </ul> <h4 id="definition">Definition</h4> <h5 id="rotateleft">rotateLeft</h5> <p><code class="language-plaintext highlighter-rouge">rotateLeft(G)</code>: Suppose <code class="language-plaintext highlighter-rouge">x</code> is the right child of <code class="language-plaintext highlighter-rouge">G</code>, make <code class="language-plaintext highlighter-rouge">G</code> the new left child of <code class="language-plaintext highlighter-rouge">x</code>.</p> <p><img src="/assets/img/cs61b/18/rotate_left_1.png" alt="rotate_left_1" width="550" loading="lazy"></p> <ul> <li>Can think of as temporarily merging <code class="language-plaintext highlighter-rouge">G</code> and <code class="language-plaintext highlighter-rouge">P</code>, then sending <code class="language-plaintext highlighter-rouge">G</code> down and left.</li> </ul> <p><img src="/assets/img/cs61b/18/rotate_left.png" alt="rotate_left" width="550" loading="lazy"></p> <h5 id="rotateright">rotateRight</h5> <p><code class="language-plaintext highlighter-rouge">rotateRight(P)</code>: Suppose <code class="language-plaintext highlighter-rouge">x</code> is the left child of <code class="language-plaintext highlighter-rouge">P</code>, make <code class="language-plaintext highlighter-rouge">P</code> the new right child of <code class="language-plaintext highlighter-rouge">x</code>.</p> <ul> <li>Can think of as temporarily merging <code class="language-plaintext highlighter-rouge">G</code> and <code class="language-plaintext highlighter-rouge">P</code>, then sending <code class="language-plaintext highlighter-rouge">P</code> down and right.</li> </ul> <p><img src="/assets/img/cs61b/18/rotate_right.png" alt="rotate_right" width="550" loading="lazy"></p> <h4 id="tree-balancing">Tree Balancing</h4> <p>Rotation:</p> <ul> <li>Can shorten (or lengthen) a tree.</li> <li>Preserves search tree property.</li> </ul> <p><img src="/assets/img/cs61b/18/rotation.png" alt="rotation" width="600" loading="lazy"></p> <p>Rotation allows balancing of a BST in $O(N)$ moves.</p> <h3 id="left-leaning-red-black-trees-llrbs">Left Leaning Red-Black Trees (LLRBs)</h3> <h4 id="tree-isometry">Tree Isometry</h4> <p>2-3 trees always remain balanced, but they are very hard to implement. On the other hand, BSTs can be unbalanced, but are simple and intuitive. Is there a way to combine the best of two worlds? Why not create <u>a tree that is implemented using a BST, but is structurally identical to a 2-3 tree and thus stays balanced</u>?</p> <p><strong>Representing a 2-3 Tree as a BST</strong></p> <p>A 2-3 tree with only 2-nodes is trivial. BST is exactly the same.</p> <p><img src="/assets/img/cs61b/18/2-nodes.png" alt="2-nodes" width="550" loading="lazy"></p> <p><strong>Dealing with 3-Nodes</strong></p> <ul> <li>Possibility 1: Create dummy “glue” nodes.</li> </ul> <p><img src="/assets/img/cs61b/18/dummy_glue_node.png" alt="dummy_glue_node" width="550" loading="lazy"> <em>Result is inelegant. Wasted link. Code will be ugly.</em></p> <ul> <li>Possibility 2: Create “glue” links with the smaller item <strong><u>off to the left</u></strong>. <ul> <li>For convenience, we’ll mark glue links as “<strong><font color="red">red</font></strong>”.</li> </ul> </li> </ul> <p><img src="/assets/img/cs61b/18/glue_link.png" alt="glue_link" width="550" loading="lazy"> <em>Idea is commonly used in practice (e.g. java.util.TreeSet).</em></p> <p>A BST with left glue links that represents a 2-3 tree is often called a “Left Leaning Red Black Binary Search Tree” or LLRB.</p> <h4 id="llrb-properties">LLRB Properties</h4> <ul> <li>Suppose we have a 2-3 tree of height H. The maximum height of the corresponding LLRB is <ul> <li>H (black) + <font color="red">H + 1 (red)</font> = 2H + 1.</li> </ul> </li> </ul> <p><img src="/assets/img/cs61b/18/LLRB.png" alt="LLRB" width="550" loading="lazy"></p> <ul> <li>No node has two red links [otherwise it’d be analogous to a 4 node, which are disallowed in 2-3 trees].</li> <li>Every path from root to null has same number of <strong><u>black links</u></strong> [because 2-3 trees have the same number of links to every leaf]. LLRBs are therefore balanced.</li> </ul> <h4 id="maintaining-isometry-with-rotations">Maintaining Isometry with Rotations</h4> <p>When inserting into an LLRB tree, we <u>always insert the new node with a red link to its parent node</u>. This is because in a 2-3 tree, we are always inserting by adding to a leaf node, the color of the link we add should always be red.</p> <p>But sometimes, inserting red links at certain places might lead to cases where we break one of the invariants of LLRBs. Below are three such cases where we need to perform certain tasks address in order to maintain the LLRB tree’s proper structure.</p> <p><strong>Case 1: Insertion on the Right</strong></p> <ul> <li>If the left child is also a red link, go to case 3.</li> <li>Otherwise, Rotate <code class="language-plaintext highlighter-rouge">E</code> left.</li> </ul> <p><img src="/assets/img/cs61b/18/case1.png" alt="case1" width="550" loading="lazy"></p> <p><strong>Case 2: Double Insertion on the Left</strong></p> <ul> <li>Rotate <code class="language-plaintext highlighter-rouge">Z</code> right. Then go to case 3.</li> </ul> <p><img src="/assets/img/cs61b/18/case2.png" alt="case2" width="550" loading="lazy"></p> <p><strong>Case 3: Node has Two Red Children</strong></p> <ul> <li>Flip the colors of all edges touching <code class="language-plaintext highlighter-rouge">B</code>.</li> </ul> <p><img src="/assets/img/cs61b/18/case3.png" alt="case3" width="350" loading="lazy"></p> <p><strong>Cascading operations</strong></p> <p>It is possible that a rotation or flip operation will cause an additional violation that needs fixing.</p> <h4 id="runtime-and-implementation">Runtime and Implementation</h4> <p>The runtime analysis for LLRBs is simple if you trust the 2-3 tree runtime.</p> <ul> <li>LLRB tree has height $O(\log N)$.</li> <li> <code class="language-plaintext highlighter-rouge">contains</code> is trivially $O(\log N)$.</li> <li> <code class="language-plaintext highlighter-rouge">insert</code> is $O(\log N)$. <ul> <li>$O(\log N)$ to add the new node.</li> <li>$O(\log N)$ rotation and color flip operations per insert.</li> </ul> </li> </ul> <h2 id="hashing">Hashing</h2> <h3 id="motivation">Motivation</h3> <p>We’ve now seen several implementations of the Set (or Map) ADT.</p> <p><img src="/assets/img/cs61b/19/set_map_implementations.png" alt="set_map_implementations" width="650" loading="lazy"></p> <p>Limits of <strong>Search Tree</strong> Based Sets:</p> <ul> <li>require items to be <strong>comparable</strong> <ul> <li>Could we somehow avoid the need for objects to be comparable?</li> </ul> </li> <li>have excellent <strong>performance</strong>, but could maybe be better <ul> <li>Could we somehow do better than $\Theta(\log N)$?</li> </ul> </li> </ul> <h3 id="the-hash-table">The Hash Table</h3> <ul> <li>Data is converted by a hash function into an integer representation called a <strong>hash code</strong>.</li> <li>The hash code is then <strong>reduced</strong> to a valid index, usually using the modulus operator, e.g. <code class="language-plaintext highlighter-rouge">2348762878 % 10 = 8</code>.</li> </ul> <p><img src="/assets/img/cs61b/19/hash_table.png" alt="hash_table" width="550" loading="lazy"></p> <h3 id="hash-table-runtime">Hash Table Runtime</h3> <p>Suppose we have: an increasing number of buckets $M$, and an increasing number of items $N$. Even if items are spread out evenly, lists are of length $Q = \frac{N}{M}$. The <code class="language-plaintext highlighter-rouge">contains(x)</code> and <code class="language-plaintext highlighter-rouge">add(x)</code> have the worst case runtimes $\Theta(Q)$.</p> <p>As long as $M = \Theta(N)$, then $O(\frac{N}{M}) = O(1)$. <strong>Resize</strong> when load factor $\frac{N}{M}$ exceeds some constant. If items are spread out nicely, you get $\Theta(1)$ average runtime. One example strategy: When $\frac{N}{M}$ is ≥ 1.5, then double $M$.</p> <h2 id="heaps-and-pqs">Heaps and PQs</h2> <h3 id="priority-queue">Priority Queue</h3> <p>(Min) Priority Queue: Allowing <strong>tracking</strong> and <strong>removal</strong> of the smallest item in a priority queue. Useful if you want to keep track of the “smallest”, “largest”, “best” etc. seen so far.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MinPQ</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/** Adds the item to the priority queue. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Item</span> <span class="n">x</span><span class="o">);</span>
    <span class="cm">/** Returns the smallest item in the priority queue. */</span>
    <span class="kd">public</span> <span class="nc">Item</span> <span class="nf">getSmallest</span><span class="o">();</span>
    <span class="cm">/** Removes the smallest item from the priority queue. */</span>
    <span class="kd">public</span> <span class="nc">Item</span> <span class="nf">removeSmallest</span><span class="o">();</span>
    <span class="cm">/** Returns the size of the priority queue. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="heaps">Heaps</h3> <h4 id="heap-structure">Heap Structure</h4> <p>BSTs would work, but need to be kept bushy and duplicates are awkward.</p> <p><strong>Binary min-heap</strong>: Binary tree that is <strong>complete</strong> and obeys <strong>min-heap</strong> property.</p> <ul> <li> <strong>Min-heap</strong>: Every node is less than or equal to both of its children.</li> <li> <strong>Complete</strong>: Missing items (if any) only at the bottom level, all nodes are as far left as possible.</li> </ul> <p><img src="/assets/img/cs61b/20/heap.png" alt="heap" loading="lazy"></p> <h4 id="add">Add</h4> <blockquote class="prompt-tip"> <p>Algorithm for <code class="language-plaintext highlighter-rouge">add(x)</code>: to maintain the <strong>completeness</strong>, the natural thought is to place <code class="language-plaintext highlighter-rouge">x</code> in the leftmost empty spot on the lowest level. However, this doesn’t guarantee the <strong>min-heap</strong> property, so further adjustments are needed.</p> </blockquote> <p><strong>swim</strong>: Continually compare <code class="language-plaintext highlighter-rouge">x</code> with its parent. If <code class="language-plaintext highlighter-rouge">x</code> is smaller, swap it with the parent. Repeat this process until <code class="language-plaintext highlighter-rouge">x</code> is in the right position.</p> <p><img src="/assets/img/cs61b/20/insert.png" alt="swim" style="zoom:100%;" loading="lazy"></p> <h4 id="delete">Delete</h4> <blockquote class="prompt-tip"> <p>Algorithm for <code class="language-plaintext highlighter-rouge">removeSmallest()</code>: to maintain the <strong>completeness</strong> of the structure, the intuitive approach is to swap the root node with the node at the end, then remove it. However, this doesn’t guarantee the <strong>min-heap</strong> property, so further adjustments are needed.</p> </blockquote> <p class="prompt-info"><strong>sink</strong>: Continually compare <code class="language-plaintext highlighter-rouge">x</code> with its left and right nodes. Swap x with the smaller of the two nodes. Repeat this process until <code class="language-plaintext highlighter-rouge">x</code> is in the right position.</p> <p><img src="/assets/img/cs61b/20/remove.png" alt="sink" style="zoom:80%;" loading="lazy"></p> <h4 id="heap-operations-summary">Heap Operations Summary</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">getSmallest()</code> - return the item in the root node.</li> <li> <code class="language-plaintext highlighter-rouge">add(x)</code> - place the new employee in the last position, and promote as high as possible.</li> <li> <code class="language-plaintext highlighter-rouge">removeSmallest()</code> - assassinate the president (of the company), promote the rightmost person in the company to president. Then demote repeatedly, always taking the ‘better’ successor.</li> </ul> <h3 id="tree-representation">Tree Representation</h3> <p>How do we Represent a Tree in Java?</p> <p><img src="/assets/img/cs61b/20/tree.png" alt="tree" style="zoom:50%;" loading="lazy"></p> <p>####c Create mapping from node to children.</p> <p><img src="/assets/img/cs61b/20/ap1digrams.png" alt="ap1digrams" width="550" loading="lazy"></p> <p><img src="/assets/img/cs61b/20/ap1codes.png" alt="ap1codes" width="550" loading="lazy"></p> <p>#### Store keys in an array. Store parentIDs in an array.</p> <ul> <li>Similar to what we did with disjointSets.</li> </ul> <p><img src="/assets/img/cs61b/20/ap2-1.png" alt="ap2-1" style="zoom: 40%;" loading="lazy"></p> <p>A more complex example：</p> <p><img src="/assets/img/cs61b/20/ap2-2.png" alt="ap2-2" width="550" loading="lazy"></p> <p>#### Store keys in an array. Don’t store structure anywhere.</p> <p>In Approach2, we observe that when numbering a binary tree in the order of level traversal, if the tree has the property of being complete, there is a pattern between the parent and child node numbers: <strong>the parent number</strong> corresponding to <strong>the node number</strong> $k$ is $\frac{k-1}{2}$.</p> <p>Further, if we leave the 0th position empty, the following patterns emerge:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">leftChild(k)</code> $= 2k$</li> <li> <code class="language-plaintext highlighter-rouge">rightChild(k)</code> $= 2k + 1$</li> <li> <code class="language-plaintext highlighter-rouge">parent(k)</code> = $\frac{k}{2}$</li> </ul> <p><img src="/assets/img/cs61b/20/ap3.png" alt="ap3" loading="lazy"></p> <h2 id="tree-and-graph-traversals">Tree and Graph Traversals</h2> <h3 id="trees-1">Trees</h3> <h4 id="tree-definition">Tree Definition</h4> <p>A tree consists of a set of <strong>nodes</strong> and a set of <strong>edges</strong> that connect those nodes, where there is <strong>exactly one</strong> path between any two nodes.</p> <p><img src="/assets/img/cs61b/21/graphs.png" alt="graphs" width="500" loading="lazy"> <em>Green structures below are trees. Pink ones are not.</em></p> <h4 id="tree-traversals">Tree Traversals</h4> <p>Sometimes you want to iterate over a tree. What one might call “tree iteration” is actually called “<strong>tree traversal</strong>”. Unlike lists, there are many orders in which we might visit the nodes.</p> <p><img src="/assets/img/cs61b/21/tree.png" alt="tree" width="350" loading="lazy"></p> <h5 id="level-order">Level Order</h5> <ul> <li>DBFACEG</li> </ul> <h5 id="depth-first-traversals">Depth First Traversals</h5> <p><img src="/assets/img/cs61b/21/tree_traversal_algo.png" alt="tree_traversal_algo" loading="lazy"> <em>DBACFEG | ABCDEFG | ACBEGFD</em></p> <h4 id="usefulness-of-tree-traversals">Usefulness of Tree Traversals</h4> <h5 id="preorder-traversal-for-printing-directory-listing">Preorder Traversal for printing directory listing</h5> <p><img src="/assets/img/cs61b/21/directory_listing.png" alt="directory_listing" width="450" loading="lazy"></p> <h5 id="postorder-traversal-for-gathering-file-sizes">Postorder Traversal for gathering file sizes</h5> <p><img src="/assets/img/cs61b/21/file_sizes.png" alt="file_sizes" width="650" loading="lazy"></p> <h3 id="graphs">Graphs</h3> <h4 id="graph-definition">Graph Definition</h4> <p>Trees are fantastic for representing strict hierarchical relationships. But not every relationship is hierarchical. A <strong>graph</strong> consists of a set of <strong>nodes</strong> and a set of zero or more <strong>edges</strong>, each of which connects two nodes. Note, all trees are graphs.</p> <p>A <strong>simple graph</strong> is a graph with:</p> <ul> <li>No edges that connect a vertex to itself, i.e. no “length 1 loops”.</li> <li>No two edges that connect the same vertices, i.e. no “parallel edges”.</li> </ul> <p><img src="/assets/img/cs61b/21/simple_graph.png" alt="simpl_graph" width="350" loading="lazy"> <em>Green graph below is simple, pink graphs are not.</em></p> <p>In 61B, unless otherwise explicitly stated, all graphs will be simple.</p> <h4 id="graph-types">Graph Types</h4> <p><img src="/assets/img/cs61b/21/graph_terms.png" alt="graph_terms" width="500" loading="lazy"></p> <h4 id="graph-problems">Graph Problems</h4> <p>Some well known graph problems and their common names:</p> <ul> <li> <strong>s-t Path</strong>. Is there a path between vertices s and t?</li> <li> <strong>Connectivity</strong>. Is the graph connected, i.e. is there a path between all vertices?</li> <li> <strong>Biconnectivity</strong>. Is there a vertex whose removal disconnects the graph?</li> <li> <strong>Shortest s-t Path</strong>. What is the shortest path between vertices s and t?</li> <li> <strong>Cycle Detection</strong>. Does the graph contain any cycles?</li> <li> <strong>Euler Tour</strong>. Is there a cycle that uses every edge exactly once?</li> <li> <strong>Hamilton Tour</strong>. Is there a cycle that uses every vertex exactly once?</li> <li> <strong>Planarity</strong>. Can you draw the graph on paper with no crossing edges?</li> <li> <strong>Isomorphism</strong>. Are two graphs isomorphic (the same graph in disguise)?</li> </ul> <h3 id="graph-traversals">Graph Traversals</h3> <h4 id="motivation-s-t-connectivity">Motivation: s-t Connectivity</h4> <p>Let’s solve a classic graph problem called the s-t connectivity problem. Given source vertex <code class="language-plaintext highlighter-rouge">s</code> and a target vertex <code class="language-plaintext highlighter-rouge">t</code>, is there a path between <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>?</p> <blockquote class="prompt-info"> <p>A <strong>path</strong> is a sequence of vertices connected by edges.</p> </blockquote> <p><img src="/assets/img/cs61b/21/s-t_connectivity.png" alt="s-t_connectivity" width="400" loading="lazy"></p> <p>One possible recursive algorithm for <code class="language-plaintext highlighter-rouge">connected(s, t)</code>.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">neighbors_of</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">connected</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div> <p>What is wrong with it? Can get caught in an infinite loop. Example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>connected(0, 7):
    Does 0 == 7? No, so...
    If (connected(1, 7)) return true;
connected(1, 7):
    Does 1 == 7? No, so…
    If (connected(0, 7)) … ← Infinite loop.
</code></pre></div></div> <p>How do we fix it?</p> <h4 id="depth-first-search">Depth First Search</h4> <p>Basic idea is same as before, but visit each vertex at most once. [<a href="https://docs.google.com/presentation/d/1OHRI7Q_f8hlwjRJc8NPBUc1cMu5KhINH1xGXWDfs_dA/edit?usp=sharing" rel="external nofollow noopener" target="_blank">Demo</a>]</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>   <span class="c1"># added
</span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">neighbors_of</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="c1"># added
</span>            <span class="k">if</span> <span class="nf">connected</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div> <h4 id="tree-vs-graph-traversals">Tree vs. Graph Traversals</h4> <h5 id="another-example-depthfirstpaths">Another example: DepthFirstPaths</h5> <p>Find a path from <code class="language-plaintext highlighter-rouge">s</code> to every other reachable vertex. [<a href="https://docs.google.com/presentation/d/1lTo8LZUGi3XQ1VlOmBUF9KkJTW_JWsw_DOPq8VBiI3A/edit#slide=id.g76e0dad85_2_380" rel="external nofollow noopener" target="_blank">Demo</a>]</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">neighbors_of</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
            <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></div> <p>This is called “<strong>DFS Preorder</strong>”. i.e., <strong>Action</strong> (setting <code class="language-plaintext highlighter-rouge">edgeTo</code>) is before DFS calls to neighbors. One valid DFS preorder for this graph: <code class="language-plaintext highlighter-rouge">012543678</code>, equivalent to the order of <strong>dfs calls</strong>.</p> <p><img src="/assets/img/cs61b/21/s-t_connectivity.png" alt="s-t_connectivity" width="400" loading="lazy"></p> <p>We could also do actions in <strong>DFS Postorder</strong>. i.e., Action is after DFS calls to neighbors. Example:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">neighbors_of</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
      <span class="nf">dfs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div> <p>Results for <code class="language-plaintext highlighter-rouge">dfs(0)</code> would be: <code class="language-plaintext highlighter-rouge">347685210</code>, equivalent to the order of <strong>dfs returns</strong>.</p> <p>Just as there are many tree traversals, so too are there many graph traversals:</p> <ul> <li> <strong>DFS Preorder</strong>: <code class="language-plaintext highlighter-rouge">012543678</code> (dfs calls).</li> <li> <strong>DFS Postorder</strong>: <code class="language-plaintext highlighter-rouge">347685210</code> (dfs returns).</li> <li> <strong>BFS order</strong>: Act in order of distance from <code class="language-plaintext highlighter-rouge">s</code>. <ul> <li>BFS stands for “breadth first search”.</li> <li>Analogous to “level order”. Search is wide, not deep.</li> <li><code class="language-plaintext highlighter-rouge">0 1 24 53 68 7</code></li> </ul> </li> </ul> <h3 id="summary-3">Summary</h3> <p>Graphs are a more general idea than a tree. A tree is a graph where there are no cycles and every vertex is connected. Graph problems vary widely in difficulty. Common tool for solving almost all graph problems is traversal. A <strong>traversal</strong> is an order in which you visit / act upon vertices.</p> <ul> <li>Tree traversals: Preorder, inorder, postorder, level order.</li> <li>Graph traversals: DFS preorder, DFS postorder, BFS.</li> </ul> <p>By performing actions / setting instance variables during a graph (or tree) traversal, you can solve problems like s-t connectivity or path finding.</p> <h2 id="graph-traversals-and-implementations">Graph Traversals and Implementations</h2> <h3 id="breadth-first-search">Breadth First Search</h3> <h4 id="shortest-paths-challenge">Shortest Paths Challenge</h4> <p>Given the graph above, find the shortest path from <code class="language-plaintext highlighter-rouge">s</code> to all other vertices.</p> <p>BFS Answer [<a href="https://docs.google.com/presentation/d/1JoYCelH4YE6IkSMq_LfTJMzJ00WxDj7rEa49gYmAtc4/edit?usp=sharing" rel="external nofollow noopener" target="_blank">Demo</a>]</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs</span><span class="p">():</span>
    <span class="n">fringe</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">s</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">fringe</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">neighbors_of</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="c1">#
</span>            <span class="n">fringe</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></div> <h3 id="graph-representations">Graph Representations</h3> <h4 id="adjacency-matrix">Adjacency Matrix</h4> <p><img src="/assets/img/cs61b/22/adjacency_matrix.png" alt="adjacency_matrix" width="350" loading="lazy"></p> <p>DFS, BFS Runtime: $O(V^2)$</p> <h4 id="edge-sets">Edge Sets</h4> <p><img src="/assets/img/cs61b/22/edge_sets.png" alt="edge_sets" width="350" loading="lazy"></p> <h4 id="adjacency-lists">Adjacency Lists</h4> <p>Common approach: Maintain array of lists indexed by vertex number. Most popular approach for representing graphs. Efficient when graphs are “sparse” (not too many edges).</p> <p><img src="/assets/img/cs61b/22/adjacency_lists.png" alt="adjacency_lists" width="400" loading="lazy"></p> <p>DFS, BFS Runtime: $O(V+E)$</p> </div> </article> </div> </div> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="" integrity="" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?24942e121cfda2aba3d081e7fdf38369"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1H8VDR0JJ"></script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>