<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Trirong"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?b8ef20a79f5306f65378fcc706e98671" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nasang.github.io/blog/course/2024/CS61B-Notes-3-Algorithms/"> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Na</span> Sang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">CS 61B (Sp21) Notes 3, Algorithms</h1> <p class="post-meta"> Created in November 09, 2024 by <na_id> </na_id></p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/data-structures"> <i class="fa-solid fa-hashtag fa-sm"></i> data structures</a>   <a href="/blog/tag/algorithms"> <i class="fa-solid fa-hashtag fa-sm"></i> algorithms</a>   ·   <a href="/blog/category/course"> <i class="fa-solid fa-tag fa-sm"></i> course</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="23-shortest-paths">23. Shortest Paths</h2> <h3 id="231-introduction">23.1 Introduction</h3> <h4 id="2311-why-bfs-doesnt-work">23.1.1 Why BFS Doesn’t Work</h4> <p>BFS would <strong>not</strong> be a good choice for a google maps style navigation application. BFS returns path with shortest <strong>number of edges</strong>, not necessarily the shortest path.</p> <p><img src="/assets/img/cs61b/23/bfs_example.png" alt="bfs_example" width="550" loading="lazy"> <em>BFS yields a route of length ~330 m instead of ~150 m.</em></p> <p>We need an algorithm that takes into account edge distances, also known as <strong>edge weights</strong>.</p> <h4 id="2312-the-shortest-paths-tree">23.1.2 The Shortest Paths Tree</h4> <h5 id="single-source-single-target-shortest-path">Single Source Single Target Shortest Path</h5> <p><img src="/assets/img/cs61b/23/single_source_single_target.png" alt="single_source_single_target" width="450" loading="lazy"> <em>Find the shortest paths from source vertex s to some target vertex t.</em></p> <p>Observation: Solution will always be a path with no cycles (assuming non-negative weights).</p> <h5 id="single-source-shortest-paths">Single Source Shortest Paths</h5> <p><img src="/assets/img/cs61b/23/single_source.png" alt="single_source" width="450" loading="lazy"> <em>Find the shortest paths from source vertex s to every other vertex.</em></p> <p>Observation: Solution will always be a <strong>tree</strong>. (Can think of as the union of the shortest paths to all vertices.) This is so-called <strong>Shortest Paths Tree</strong> (SPT).</p> <h3 id="232-dijkstras-algorithm">23.2 Dijkstra’s Algorithm</h3> <h4 id="2321-algorithm">23.2.1 Algorithm</h4> <p>We can find the SPT using <strong>Dijkstra’s algorithm</strong> [<a href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g771336078_0_180" rel="external nofollow noopener" target="_blank">Demo</a>]. Perform a <strong>best first search</strong>: Visit vertices in <strong>order of best-known distance</strong> from source. On visit, <strong><em>relax</em></strong> every edge from the visited vertex.</p> <blockquote class="prompt-info"> <p><strong>Relax</strong>: If we find a better path, update our preferred edge and distance.</p> </blockquote> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">():</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">([])</span>   <span class="c1"># priority queue; i.e., min heap
</span>    <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
        <span class="n">dis</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors_of</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="c1"># relax ⬇
</span>            <span class="k">if</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">distTo</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="n">distTo</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">weight</span>
                <span class="n">edgeTo</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">distTo</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
            <span class="c1"># relax ⬆
</span></code></pre></div></div> <h4 id="2322-correctness">23.2.2 Correctness</h4> <p>Dijkstra’s is guaranteed to return a correct result if all edges are non-negative.</p> <h3 id="233-a-algorithm">23.3 A* Algorithm</h3> <p>If we have only a single target in mind, A* algorithm can do better:</p> <blockquote class="prompt-tip"> <p><strong>A* Algorithm</strong> Visit vertices in order of <code class="language-plaintext highlighter-rouge">d(source, v) + h(v, goal)</code>, where <code class="language-plaintext highlighter-rouge">h(v, goal)</code> is an estimate of the distance from v to our goal. [<a href="https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g771336078_0_180" rel="external nofollow noopener" target="_blank">Demo</a>]</p> </blockquote> <h2 id="24-minimum-spanning-trees">24. Minimum Spanning Trees</h2> <h3 id="241-concepts">24.1 Concepts</h3> <p>Given an <strong>undirected</strong> graph <code class="language-plaintext highlighter-rouge">G</code>, a <strong>spanning tree</strong> <code class="language-plaintext highlighter-rouge">T</code> is a subgraph of <code class="language-plaintext highlighter-rouge">G</code>, where <code class="language-plaintext highlighter-rouge">T</code>:</p> <ul> <li>Is connected and acyclic. (make it a tree)</li> <li>Includes all of the vertices. (makes it spanning)</li> </ul> <p><img src="/assets/img/cs61b/24/mst.png" alt="mst" width="300" loading="lazy"></p> <p>A <strong><em>minimum spanning tree</em></strong> (MST) is a spanning tree of minimum total weight.</p> <h3 id="242-the-cut-property">24.2 The Cut Property</h3> <h4 id="2421-concepts">24.2.1 Concepts</h4> <ul> <li>A <strong>cut</strong> is an assignment of a graph’s nodes to two non-empty sets.</li> <li>A <strong>crossing edge</strong> is an edge which connects a node from one set to a node from the other set.</li> <li> <strong>Cut property</strong>: Given any cut, minimum weight crossing edge is in the MST. (assume edge weights are unique)</li> </ul> <p><img src="/assets/img/cs61b/24/cut_property.png" alt="cut_property" width="350" loading="lazy"></p> <h4 id="2422-proof">24.2.2 Proof</h4> <p>Suppose that the minimum crossing edge <code class="language-plaintext highlighter-rouge">e</code> were not in the MST.</p> <ul> <li>Adding <code class="language-plaintext highlighter-rouge">e</code> to the MST creates a cycle.</li> <li>Some other edge <code class="language-plaintext highlighter-rouge">f</code> must also be a crossing edge.</li> <li>Removing <code class="language-plaintext highlighter-rouge">f</code> and adding <code class="language-plaintext highlighter-rouge">e</code> is a lower weight spanning tree. Contradiction!</li> </ul> <p><img src="/assets/img/cs61b/24/cut_property_proof.png" alt="cut_property_proof" width="450" loading="lazy"></p> <h3 id="243-algorithms">24.3 Algorithms</h3> <h4 id="2431-prims-algorithm">24.3.1 Prim’s Algorithm</h4> <p><strong>Prim’s Algorithm</strong> [<a href="https://docs.google.com/presentation/d/1NFLbVeCuhhaZAM1z3s9zIYGGnhT4M4PWwAc-TLmCJjc/edit#slide=id.g9a60b2f52_0_0" rel="external nofollow noopener" target="_blank">Demo</a>]: Start from some arbitrary start node. Add shortest edge that has <strong>one</strong> node inside the MST under construction. Repeat until $V-1$ edges.</p> <p><img src="/assets/img/cs61b/24/prim.png" alt="prim" loading="lazy"></p> <p><strong>Implementation</strong> [<a href="https://docs.google.com/presentation/d/1GPizbySYMsUhnXSXKvbqV4UhPCvrt750MiqPPgU-eCY/edit#slide=id.g9a60b2f52_0_0" rel="external nofollow noopener" target="_blank">Demo</a>]: Insert all vertices into fringe <code class="language-plaintext highlighter-rouge">PQ</code>, storing vertices in order of distance from tree. Repeat: Remove (closest) vertex <code class="language-plaintext highlighter-rouge">v</code> from <code class="language-plaintext highlighter-rouge">PQ</code>, and relax all edges pointing from <code class="language-plaintext highlighter-rouge">v</code>.</p> <h4 id="2432-kruskals-algorithm">24.3.2 Kruskal’s Algorithm</h4> <p><strong>Kruskal’s Algorithm</strong> [<a href="https://docs.google.com/presentation/d/1RhRSYs9Jbc335P24p7vR-6PLXZUl-1EmeDtqieL9ad8/edit#slide=id.g9a60b2f52_0_0" rel="external nofollow noopener" target="_blank">Demo</a>]: Consider edges in order of increasing weight. Add to MST unless a cycle is created. Repeat until $V-1$ edges.</p> <p><img src="/assets/img/cs61b/24/kruskals.png" alt="kruskals" loading="lazy"> <em>Blue and green colorings for vertices show cut being implicitly utilized by Kruskal’s algorithm.</em></p> <p><strong>Implementation</strong> [<a href="https://docs.google.com/presentation/d/1KpNiR7aLIEG9sm7HgX29nvf3yLD8_vdQEPa0ktQfuYc/edit?usp=sharing" rel="external nofollow noopener" target="_blank">Demo</a>]: Insert all edges into <code class="language-plaintext highlighter-rouge">PQ</code>. Repeat: Remove smallest weight edge. Add to MST if no cycle created. Use Weighted Quick Union UF (WQU) to detech cycle: For each edge, check if the two vertices are connected. If not, union them. If so, there is a cycle.</p> <h2 id="26-prefix-operations-and-tries">26. Prefix Operations and Tries</h2> <h3 id="261-introduction">26.1 Introduction</h3> <p>HashMaps are already incredibly fast. But if we have some additional insight on the data we are storing, we could get even faster.</p> <h4 id="special-case-1-character-keyed-map">Special Case 1: <strong>Character Keyed Map</strong> </h4> <p>Suppose we know that our keys are always ASCII characters. We can just use an array. Simple and fast.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataIndexedCharMap</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">V</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
    <span class="c1">// R is the number of possible characters, e.g. 128 for ASCII.</span>
    <span class="kd">public</span> <span class="nf">DataIndexedCharMap</span><span class="o">(</span><span class="kt">int</span> <span class="no">R</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">items</span> <span class="o">=</span> <span class="o">(</span><span class="no">V</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">R</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">,</span> <span class="no">V</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">items</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="special-case-2-string-keyed-map">Special Case 2: String Keyed Map</h4> <p>Suppose we know that our keys are always strings. We can use a special data structure known as a <strong>Trie</strong>. The basic idea: store <strong>each letter</strong> of the string as a node in a tree.</p> <p><strong>Trie</strong>: Short for Re<strong>trie</strong>val Tree. Inventor <em>Edward Fredkin</em> suggested it should be pronounced “tree”, but almost everyone pronounces it like “try”.</p> <p><img src="/assets/img/cs61b/26/trie_map.png" alt="trie" width="500" loading="lazy"> <em>Use Trie to implement Map</em></p> <p><img src="/assets/img/cs61b/26/set.png" alt="set" width="500" loading="lazy"> <em>different implementations of set</em></p> <h3 id="262-trie-implementation">26.2 Trie Implementation</h3> <h4 id="2621-basic-trie-implementation">26.2.1 Basic Trie Implementation</h4> <p>The first approach might look something like the code below. Each node stores a letter (<code class="language-plaintext highlighter-rouge">ch</code>), a map from <code class="language-plaintext highlighter-rouge">ch</code> to all child nodes (<code class="language-plaintext highlighter-rouge">next</code>), and a color (<code class="language-plaintext highlighter-rouge">isKey</code>).</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrieSet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="mi">128</span><span class="o">;</span> <span class="c1">// ASCII</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>	<span class="c1">// root of trie</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="c1">// private char ch; removed</span>
        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isKey</span><span class="o">;</span>
        <span class="c1">// Since we know our keys are characters, can use a DataIndexedCharMap.   </span>
        <span class="kd">private</span> <span class="nc">DataIndexedCharMap</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nf">Node</span><span class="o">(</span> <span class="cm">/*char c, removed*/</span> <span class="kt">boolean</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="no">R</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ch = c; removed</span>
            <span class="n">isKey</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataIndexedCharMap</span><span class="o">&lt;&gt;(</span><span class="no">R</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>Since we use a <code class="language-plaintext highlighter-rouge">DataIndexedCharMap</code> to track children, every node has <code class="language-plaintext highlighter-rouge">R</code> links, mostly <code class="language-plaintext highlighter-rouge">null</code>. Observation: The letter stored inside each node is actually redundant. Can remove from the representation and things will work fine.</p> <p><img src="/assets/img/cs61b/26/basic_impl.png" alt="basic_impl" width="550" loading="lazy"></p> <p>Assuming the length of the key is $L$, the runtime of <code class="language-plaintext highlighter-rouge">add</code> is $\Theta(L)$ and that of <code class="language-plaintext highlighter-rouge">contain</code> is $O(L)$.</p> <h4 id="2622-alternate-child-tracking-strategies">26.2.2 Alternate Child Tracking Strategies</h4> <p>Using a <code class="language-plaintext highlighter-rouge">DataIndexedCharMap</code> is very memory hungry. Every node has to store <code class="language-plaintext highlighter-rouge">R</code> links, most of which are <code class="language-plaintext highlighter-rouge">null</code>. Using BST or Hash Table will be slightly slower, but more memory efficient.</p> <p><img src="/assets/img/cs61b/26/implementation.png" alt="implementation" width="750" loading="lazy"> <em>The Hash-Table Based Trie (mid) and The BST-Based Trie (right)</em></p> <h4 id="2623-performance">26.2.3 Performance</h4> <p>Using a BST or a Hash Table to store links to children will usually use less memory.</p> <ul> <li>DataIndexedCharMap: 128 links per node.</li> <li>BST: $C$ links per node, where $C$ is the number of children.</li> <li>Hash Table: $C$ links per node.</li> <li>Note: Cost per link is higher in BST and Hash Table.</li> </ul> <p>Using a BST or a Hash Table will take slightly more time.</p> <ul> <li>DataIndexedCharMap is $\Theta(1)$.</li> <li>BST is $O(\log R)$, where $R$ is size of alphabet.</li> <li>Hash Table is $O(R)$, where $R$ is size of alphabet.</li> <li>Since $R$ is fixed (e.g. 128), can think of all 3 as $\Theta(1)$.</li> </ul> <h3 id="263-trie-string-operations">26.3 Trie String Operations</h3> <p>Theoretical asymptotic speed improvement is nice. But the main appeal of tries is their ability to efficiently support string specific operations like <strong>prefix matching</strong>.</p> <ul> <li>Finding all keys that match a given prefix: <code class="language-plaintext highlighter-rouge">keysWithPrefix("sa")</code> </li> <li>Finding longest prefix of: <code class="language-plaintext highlighter-rouge">longestPrefixOf("sample")</code> </li> </ul> <h4 id="2631-collecting-trie-keys">26.3.1 Collecting Trie Keys</h4> <p>Give an algorithm for collecting all the keys in a Trie.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrieSet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="mi">128</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isKey</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">private</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="no">R</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">isKey</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="no">R</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">collect</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="nl">c:</span> <span class="n">root</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">colHelp</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">colHelp</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">isKey</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="nl">c:</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">colHelp</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="2632-keyswithprefix">26.3.2 keysWithPrefix</h4> <p>Give an algorithm for <code class="language-plaintext highlighter-rouge">keysWithPrefix</code>.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TrieSet</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="nl">c:</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="n">prefix</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="nl">c:</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">colHelp</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">colHelp</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">isKey</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Character</span> <span class="nl">c:</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">colHelp</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="264-autocomplete">26.4. Autocomplete</h3> <h4 id="2641-the-autocomplete-problem">26.4.1 The Autocomplete Problem</h4> <p>Example, when I type “how are” into Google, I get 10 results, shown to the below.</p> <p>One way to do this is to create a <strong>Trie based map</strong> from strings to values</p> <ul> <li>Value represents how important Google thinks that string is.</li> <li>Can store billions of strings efficiently since they share nodes.</li> <li>When a user types in a string “hello”, we: <ul> <li>Call <code class="language-plaintext highlighter-rouge">keysWithPrefix("hello")</code>.</li> <li>Return the 10 strings with the highest value.</li> </ul> </li> </ul> <p><img src="/assets/img/cs61b/26/google_search.png" alt="google_search" width="300" loading="lazy"></p> <p>The approach above has one major flaw. If we enter a short string, the number of keys with the appropriate prefix will be too big.</p> <ul> <li>We are collecting billions of results only to keep 10.</li> <li>This is extremely inefficient.</li> </ul> <p><img src="/assets/img/cs61b/26/google_search_2.png" alt="google_search_2" width="300" loading="lazy"></p> <h4 id="2642-a-more-efficient-autocomplete">26.4.2 A More Efficient Autocomplete</h4> <p><img src="/assets/img/cs61b/26/efficient_autocomplete.png" alt="efficient_autocomplete" width="300" loading="lazy"></p> <p>One way to address this issue:</p> <ul> <li>Each node stores its own value, as well as the value of its best substring.</li> </ul> <p>Search will consider nodes in order of “best”.</p> <ul> <li>Consider ‘sp’ before ‘sm’.</li> <li>Can stop when top 3 matches are all better than best remaining.</li> </ul> <h4 id="2643-even-more-efficient-autocomplete">26.4.3 Even More Efficient Autocomplete</h4> <p><img src="/assets/img/cs61b/26/more_efficient_autocomplete.png" alt="more_efficient_autocomplete" width="300" loading="lazy"></p> <p>Can also merge nodes that are redundant.</p> <ul> <li>This version of trie is known as a “<strong>radix tree</strong>” or “radix trie”.</li> <li>Won’t discuss.</li> </ul> <h3 id="265-summary">26.5 Summary</h3> <p>When your key is a string, you can use a Trie:</p> <ul> <li>Theoretically better performance than hash table or search tree.</li> <li>Have to decide on a mapping from letter to node. Three natural choices: <ul> <li>DataIndexedCharMap, i.e. an array of all possible child links.</li> <li>Bushy BST.</li> <li>Hash Table.</li> </ul> </li> <li>All three choices are fine, though hash table is probably the most natural.</li> <li>Supports special string operations like <code class="language-plaintext highlighter-rouge">longestPrefixOf</code> and <code class="language-plaintext highlighter-rouge">keysWithPrefix</code>. <ul> <li> <code class="language-plaintext highlighter-rouge">keysWithPrefix</code> is the heart of important technology like autocomplete.</li> <li>Optimal implementation of Autocomplete involves use of a priority queue.</li> </ul> </li> </ul> </div> </article> </div> </div> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> </body> </html>